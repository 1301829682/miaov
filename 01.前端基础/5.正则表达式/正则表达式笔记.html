<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>无标题文档</title>

</head>

<body>
<script>
RegExp对象：
js风格：new RegExp('正则规则',attributes)
per风格：/正则规则/attributes
		attributes可选,包含属性 "g"、"i" 和 "m",分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。

attributes：
i ：ignore 忽略大小写(正则区分大小写)
g ：全局匹配


行首行尾
^行首
$行尾

量词 ：
{n,m} ：最少n次,最多m次
{n,} ：至少n次
{,m} ：至多m次
{n} : 正好n次
* ：任意次 {0,} 建议不要使用*
? ：零次或一次 {0,1}
+ ：一次或任意次{1,}


字符类：
[abc] ：a或b或c
[a-z],[0-9] ：[0-9] 所有数字相当于\d  [a-z]所有字母  [0-9a-z]数字或字母
[^a]  : 除了a以外的所有东西

转义字符：
比如查找.或*时，使用\来取消这些字符的特殊意义，转义成\.和\*
\d : digital 数字   \D : [^0-9]除了数字之外
\w : word 相当于数字字母下划线[0-9a-z_]
\s ：space 空白
. ：除换行符以外的任意字符
\b ：单词的开始或结束
\\ ：单个\

        
                      常用分组语法
捕获	    (exp)	        匹配exp,并捕获文本到自动命名的组里
            (?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
            (?:exp)	        匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	(?=exp)	        匹配exp前面的位置
            (?<=exp)	    匹配exp后面的位置
            (?!exp)	        匹配后面跟的不是exp的位置
            (?<!exp)	    匹配前面不是exp的位置
注释	    (?#comment)	    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读


后向引用：
    使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
    后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本
    \b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)
    你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b

零宽断言：
    (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
    (?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
负向零宽断言：
    零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
    同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。


贪婪与懒惰：
    当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
    有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。
    懒惰限定符
    代码/语法	    说明
    *?	            重复任意次，但尽可能少重复
    +?	            重复1次或更多次，但尽可能少重复
    ??	            重复0次或1次，但尽可能少重复
    {n,m}?	        重复n到m次，但尽可能少重复
    {n,}?	        重复n次以上，但尽可能少重复
</script>
</body>

</html>